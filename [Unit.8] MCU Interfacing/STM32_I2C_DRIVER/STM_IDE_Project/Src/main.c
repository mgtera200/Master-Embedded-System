/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
//////////////////////////////
// Eng.TERA
////////////////////////////
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

#include "STM32F103x8.h"
#include "GPIO_DRIVER.h"
#include "USART_DRIVER.h"
#include "SPI_DRIVER.h"
#include "I2C_DRIVER.h"
#include "I2C_Slave_EEPROM.h"
//
//uint16_t ch;
//Pin_Config_t Pincfg;
//
//
//
//
//
//void wait_ms(uint32_t time){
//	uint32_t i,j;
//	for(i=0; i<time; i++)
//		for(j=0; j<255; j++);
//}
//
//
//void Usart_callback(interrupts_Bits * IRQ){
//
//#ifdef MASTER
//
//	if(IRQ->RX_Interrupt)
//	{
//		//RX ISR
//		MCAL_USART_ReceiveChar(USART1, &ch);
//		MCAL_USART_SendChar(USART1, &ch);
//		//spi
//		MCAL_GPIO_WritePin(GPIOA, 4, 0);
//		MCAL_SPI_TX_RX(SPI1, &ch);
//		MCAL_GPIO_WritePin(GPIOA, 4, 1);
//	}
//#endif
//
//	if(IRQ->TX_Interrupt)
//	{
//		//TX ISR
//	}
//	if(IRQ->TC_Interrupt){
//		//TC ISR
//	}
//}
//
//
//
//
//
//void SPI_callback(Interrupt_flags_bits_t * IRQ){
//
//#ifdef SLAVE
//	if(IRQ->Receive_buffer_not_empty_flag)
//	{
//		ch=0xf;
//		MCAL_SPI_TX_RX(SPI1, &ch);
//		MCAL_USART_SendChar(USART1, &ch);
//
//	}
//#endif
//
//	//	if(IRQ->Transmit_buffer_empty_flag)
//	//	{
//	//
//	//	}
//
//}
//
 int main(void){
	//
	//
	// Enable clock
	GPIOA_CLOCK_EN();
	GPIOB_CLOCK_EN();
	AFIO_CLOCK_EN();
	//	USART1_CLOCK_EN();
	//	SPI1_CLOCK_EN();
	//
	//	USART_Config_t UART_CNFG_s;
	//	UART_CNFG_s.Async_EN = Enable;
	//	UART_CNFG_s.Async_Config_s.Baud_Rate = 115200;
	//	UART_CNFG_s.Async_Config_s.Stop_Bits = Stop_1;
	//	UART_CNFG_s.Async_Config_s.Word_Length =Eight_bits;
	//	UART_CNFG_s.interrupts_CNFG.RX_Interrupt_Enable_Or_Disable = Enable;
	//	UART_CNFG_s.interrupts_CNFG.TX_Interrupt_Enable_Or_Disable = Disable;
	//	UART_CNFG_s.interrupts_CNFG.TC_Interrupt_Enable_Or_Disable = Disable;
	//	UART_CNFG_s.CallBack_FN = Usart_callback;
	//	MCAL_USART_Init(USART1, &UART_CNFG_s);
	//
	//	MCAL_USART_GPIO_Pins_Config(USART1);
	//
	//	SPI_Config_t spi_cnfg;
	//	spi_cnfg.SPI_MODES =SPI_COMM_MODE_2LINES_TX_RX;
	//	spi_cnfg.data_frame =data_8_bits;
	//	spi_cnfg.clock_phase= First_ck_transition_first_data;
	//	spi_cnfg.clock_polarity =Clock_high_when_idle;
	//	spi_cnfg.data_frame = MSB_transmitted_first;
	//	spi_cnfg.Baud_rate_control = CLK_DIVIDED_8;
	//
	//#ifdef MASTER
	//	spi_cnfg.Tx_buffer_empty_interrupt = Interrupt_Disable;
	//	spi_cnfg.RX_buffer_not_empty_interrupt = Interrupt_Disable;
	//	spi_cnfg.MASTER_OR_SLAVE = Master;
	//	spi_cnfg.CallBack_PTR =NULL;
	//	spi_cnfg.NSS_Management =SPI_NSS_SOFTWARE_INTERNAL_SS_SET;
	//
	//	//config PA4
	//	Pincfg.Pin_Num=4;
	//	Pincfg.mode =Output_ALF_Push_pull;
	//	Pincfg.Speed_Output=speed_10;
	//	MCAL_GPIO_Init(GPIOA, &Pincfg);
	//
	//	MCAL_GPIO_WritePin(GPIOA, 4, 1);
	//#endif
	//
	//#ifdef SLAVE
	//	spi_cnfg.RX_buffer_not_empty_interrupt = Interrupt_Enable;
	//	spi_cnfg.Tx_buffer_empty_interrupt = Interrupt_Disable;
	//	spi_cnfg.MASTER_OR_SLAVE = Slave;
	//	spi_cnfg.NSS_Management =SPI_NSS_HARDWARE_SLAVE;
	//	spi_cnfg.CallBack_PTR =SPI_callback;
	//
	//#endif
	//
	//	MCAL_SPI_Init(SPI1, &spi_cnfg);
	//	MCAL_SPI_GPIO_PINS_CONFIG(SPI1);




	//#ifdef MASTER
	//
	//	Pin_Config_t Pin_CNFG;
	//	Pin_CNFG.Pin_Num = 4;
	//	Pin_CNFG.Speed_Output = speed_10;
	//	Pin_CNFG.mode = Output_Push_pull;
	//	MCAL_GPIO_Init(GPIOA, &Pin_CNFG);
	//
	//	MCAL_GPIO_WritePin(GPIOA, 4, 1);
	//#endif

	//TEST CASE 1
	unsigned char ch1 []= {0x1,0x2,0x3,0x4,0x5,0x6,0x7};
	unsigned char ch2 [7]={0};

	eeprom_init();
	eeprom_write_Nbytes(0xAF, ch1, 7);
	eeprom_read_byte(0xAF,ch2, 7);


	//TEST CASE 2
	ch1[0] = 0xA;
	ch1[1] = 0xB;
	ch1[2] = 0xC;
	ch1[3] = 0xD;

	eeprom_write_Nbytes(0xFFF, ch1, 4);
	eeprom_read_byte(0xFFF,ch2, 4);




	while(1)
	{

		//				MCAL_USART_RecieveChar(USART1, &buff);
		//				MCAL_USART_SendChar(USART1, &buff);

	}

}



