/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
//////////////////////////////
// Eng.TERA
////////////////////////////

#include "STM32F103x8.h"
#include "Scheduler.h"
#include "core_cm3.h"
#include "CortexMx_OS_Porting.h"

Task_Creation Task1,Task2,Task3,Task4;
Mutex_Creation mutex1,mutex2;
uint8_t payload[3] = {1,2,3};
uint8_t payload2[3] = {1,2,3};




uint8_t Task1LED,Task2LED,Task3LED,Task4LED=0;


void task1(void) {
	static int count =0;
	while(1)
	{
		//Task 1 code
		Task1LED ^= 1;
		count++;
		if(count == 100)
		{
			teraRTOS_AcquireMutex(&mutex1, &Task1);
			teraRTOS_ActivateTask(&Task4);
			teraRTOS_AcquireMutex(&mutex2, &Task1);

		}
		if(count == 200)
		{
			count =0;
			teraRTOS_ReleaseMutex(&mutex1);
		}

		//		teraRTOS_TaskWait(100, &Task1);

	}
}

void task2(void) {

	static int count =0;
	while(1)
	{
		//Task 1 code
		Task2LED ^= 1;
		count++;
		if(count == 100)
		{
			teraRTOS_ActivateTask(&Task3);
		}
		if(count == 200)
		{
			count =0;
			teraRTOS_TerminateTask(&Task2);
		}
		//		teraRTOS_TaskWait(100, &Task1);

	}
}

void task3(void) {

	static int count =0;
	while(1)
	{
		//Task 3 code
		Task3LED ^= 1;
		count++;
		if(count == 100)
		{
			teraRTOS_ActivateTask(&Task4);
		}
		if(count == 200)
		{
			count =0;
			teraRTOS_TerminateTask(&Task3);
		}
		//		teraRTOS_TaskWait(100, &Task1);

	}
}

void task4(void) {

	static int count =0;
	while(1)
	{
		//Task 4 code
		Task4LED ^= 1;
		count++;
		if(count == 3)
		{
			teraRTOS_AcquireMutex(&mutex2, &Task4);
			teraRTOS_AcquireMutex(&mutex1, &Task4);
		}
		if(count == 200)
		{
			count =0;
			teraRTOS_ReleaseMutex(&mutex1);
			teraRTOS_TerminateTask(&Task4);
		}
		//		teraRTOS_TaskWait(100, &Task1);

	}
}



int main(void){

	TERA_RTOS_ErrorType Error;
	//HW INIT (Initialize ClockTree, ResetController)
	HW_init();

	if(TERA_RTOS_init() != NoError)
		while(1);

	mutex1.PayloadSize = 3;
	mutex1.Payload_P = payload;
	strcpy(mutex1.Mutex_Name,"mutex1");

	mutex2.PayloadSize = 3;
	mutex2.Payload_P = payload2;
	strcpy(mutex2.Mutex_Name,"mutex2");


	Task1.Stack_Size = 1024;
	Task1.TaskEntry_Ptr = task1;
	Task1.Priority = 4;
	strcpy(Task1.TaskName, "Task_1");

	Task2.Stack_Size = 1024;
	Task2.TaskEntry_Ptr = task2;
	Task2.Priority = 3;
	strcpy(Task2.TaskName, "Task_2");

	Task3.Stack_Size = 1024;
	Task3.TaskEntry_Ptr = task3;
	Task3.Priority = 2;
	strcpy(Task3.TaskName, "Task_3");


	Task4.Stack_Size = 1024;
	Task4.TaskEntry_Ptr = task4;
	Task4.Priority = 1;
	strcpy(Task3.TaskName, "Task_4");

	Error = teraRTOS_CreateTask(&Task1);
	Error = teraRTOS_CreateTask(&Task2);
	Error = teraRTOS_CreateTask(&Task3);
	Error = teraRTOS_CreateTask(&Task4);


	teraRTOS_ActivateTask(&Task1);
	//	teraRTOS_ActivateTask(&Task2);
	//	teraRTOS_ActivateTask(&Task3);
	//	teraRTOS_ActivateTask(&Task4);



	teraRTOS_START();




	while(1)
	{


	}

}
