/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

//////////////////////////////
// Eng.TERA
////////////////////////////
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

#include "STM32F103x8.h"
#include "GPIO_DRIVER.h"
#include "USART_DRIVER.h"
#include "SPI_DRIVER.h"

#define MCU_ACT_AS_MASTER
//#define MCU_ACT_AS_SLAVE
uint16_t key ;

void SPI_IRQ_CallBack(S_IRQ_SRC irq_src)
{
#ifdef MCU_ACT_AS_SLAVE

	if(irq_src.RXNE)
	{
		key = 0xf;
		MCAL_SPI_TX_RX(SPI1, &key, Polling_enable);
		MCAL_USART_SendChar(USART1, &key);
	}
#endif
}

void Usart_callback(interrupts_Bits * IRQ){

#ifdef MCU_ACT_AS_MASTER
	MCAL_USART_ReceiveChar(USART1, &key);
	MCAL_USART_SendChar(USART1, &key);

	//Send to SPI
	MCAL_GPIO_WritePin(GPIOA, 4, 0);
	MCAL_SPI_TX_RX(SPI1, &key, Polling_enable);
	MCAL_GPIO_WritePin(GPIOA, 4, 1);
#endif
}

void clock_init()

{

	//Enable clock GPIOA
	GPIOA_CLOCK_EN();
	//Enable clock GPIOB
	GPIOB_CLOCK_EN();
	AFIO_CLOCK_EN();
	USART1_CLOCK_EN();

}



int main()
{
	clock_init();


	// =================== UART INIT =====================
	USART_Config_t UART_CNFG_s;
	UART_CNFG_s.Async_EN = USART_Enable;
	UART_CNFG_s.Async_Config_s.Baud_Rate = 115200;
	UART_CNFG_s.Async_Config_s.Stop_Bits = Stop_1;
	UART_CNFG_s.Async_Config_s.Word_Length =Eight_bits;
	UART_CNFG_s.interrupts_CNFG.RX_Interrupt_Enable_Or_Disable = USART_Enable;
	UART_CNFG_s.CallBack_FN = Usart_callback;
	MCAL_USART_Init(USART1, &UART_CNFG_s);
	MCAL_USART_GPIO_Pins_Config(USART1);



	// =================== SPI INIT =====================
	//   PA4 : SPI1_NSS
	//   PA5 : SPI1_SCK
	//	 PA6 : SPI1_MISO
	//   PA7 : SPI1_MOSI
	SPI_Config_t SPI;

	// common configuration for master and slave
	SPI.CLK_PHASE = SPI_CLKPHASE_2EDGE_FIRST_DATA_CAPTURE_EDGE;
	SPI.CLK_POLARITY = SPI_CLKPOLARITY_HIGH_WHEN_IDLE;
	SPI.DATA_SZ = SPI_DATA_SIZE_8B;
	SPI.FRAME_FORMAT = SPI_FRAME_FORMAT_MSB;
	SPI.SPI_BAUDRATE_PRESCALAR = SPI_BAUDRATE_PRESCALAR_8;
	SPI.COMM_MODE = SPI_DIRECTION_2LINES;


#ifdef MCU_ACT_AS_MASTER

	SPI.DEVICE_MODE = SPI_DEVICE_MODE_MASTER;
	SPI.IRQ_ENABLE = SPI_IRQ_ENABLE_NONE;
	SPI.NSS = SPI_NSS_SW_InternalSoft_set;
	SPI.P_SPI_IRQ_CALLBACK = NULL;

	// configure SS on PA4 by GPIO
	Pin_Config_t Pincfg;
	Pincfg.Pin_Num=4;
	Pincfg.mode =Output_ALF_Push_pull;
	Pincfg.Speed_Output=speed_10;
	MCAL_GPIO_Init(GPIOA, &Pincfg);

	// Force the Slave Select (HIGH) for idle Mode
	MCAL_GPIO_WritePin(GPIOA, 4, 0);

#endif

#ifdef MCU_ACT_AS_SLAVE
	SPI.DEVICE_MODE = SPI_DEVICE_MODE_SLAVE;
	SPI.IRQ_ENABLE = SPI_IRQ_ENABLE_RXNEIE;
	SPI.NSS = SPI_NSS_HW_SLAVE;
	SPI.P_SPI_IRQ_CALLBACK = SPI_IRQ_CallBack;

#endif


	MCAL_SPI_INIT(SPI1, &SPI);
	MCAL_SPI_GPIO_SET_PINS(SPI1);


	while(1)
	{

	}
}

